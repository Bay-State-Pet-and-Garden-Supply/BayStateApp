/**
 * @jest-environment node
 */
import { updateSession } from '@/lib/supabase/middleware';
import { createServerClient } from '@supabase/ssr';
import { NextRequest, NextResponse } from 'next/server';

jest.mock('@supabase/ssr');
const mockCreateServerClient = createServerClient as jest.Mock;

describe('Middleware Auth Logic', () => {
    let mockSupabase: any;
    let mockGetUser: jest.Mock;
    let mockFrom: jest.Mock;

    beforeEach(() => {
        jest.clearAllMocks();

        mockGetUser = jest.fn();
        mockFrom = jest.fn();

        mockSupabase = {
            auth: { getUser: mockGetUser },
            from: mockFrom,
        };
        mockCreateServerClient.mockReturnValue(mockSupabase);
    });

    function createReq(path: string) {
        return new NextRequest(new URL(path, 'http://localhost'));
    }

    it('redirects unauthenticated user from /admin to unified login', async () => {
        mockGetUser.mockResolvedValue({ data: { user: null }, error: null });

        const req = createReq('/admin/dashboard');
        const res = await updateSession(req);

        // Check if redirect to login with next param
        expect(res.status).toBe(307);
        const location = new URL(res.headers.get('location') || '');
        expect(location.pathname).toBe('/login');
        expect(location.searchParams.get('next')).toBe('/admin/dashboard');
    });

    it('redirects customer role from /admin to login with error', async () => {
        mockGetUser.mockResolvedValue({ data: { user: { id: 'u1', app_metadata: { role: 'customer' } } }, error: null });

        // NO DB call needed - role comes from JWT app_metadata
        const req = createReq('/admin/dashboard');
        const res = await updateSession(req);

        // Should redirect to /login with error params
        expect(res.status).toBe(307);
        const location = new URL(res.headers.get('location') || '');
        expect(location.pathname).toBe('/login');
        expect(location.searchParams.get('error')).toBe('unauthorized');
    });

    it('redirects staff role from /admin/users to /admin/orders (or dashboard?)', async () => {
        // Staff attempting restricted route - role comes from JWT
        mockGetUser.mockResolvedValue({ data: { user: { id: 'u2', app_metadata: { role: 'staff' } } }, error: null });

        const req = createReq('/admin/users');
        const res = await updateSession(req);

        // Should redirect restricted access
        expect(res.status).toBe(307);
        // Where to? Maybe /admin/orders or /admin
        expect(res.headers.get('location')).toContain('/admin');
        expect(res.headers.get('location')).not.toContain('/admin/users');
    });

    it('allows admin access to /admin/users', async () => {
        mockGetUser.mockResolvedValue({ data: { user: { id: 'u3', app_metadata: { role: 'admin' } } }, error: null });

        // NO DB call needed - role comes from JWT app_metadata
        const req = createReq('/admin/users');
        const res = await updateSession(req);

        // Should result in next() (status 200 usually from next() mock? No, updateSession returns value)
        // updateSession returns a response generated by NextResponse.next(), which is 200 OK often?
        // Actually NextResponse.next() allows continuation.
        expect(res.status).not.toBe(307);
        expect(res.headers.get('location')).toBeNull();
    });
    it('redirects unauthenticated user from /account to /login', async () => {
        mockGetUser.mockResolvedValue({ data: { user: null }, error: null });

        const req = createReq('/account/profile');
        const res = await updateSession(req);

        expect(res.status).toBe(307);
        expect(res.headers.get('location')).toBe('http://localhost/login');
    });
});
